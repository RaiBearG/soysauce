#pragma config(Sensor, S2,     touch,           sensorEV3_Touch)
#pragma config(Motor,  motorA,          a,             tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          b,             tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          c,             tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// **-- MAZE SOLVER--** //


typedef struct{
/*
Structure defination to keep track of the walls in each cell of the 4x6 maze 
*/
	int NorthWall;
	int EastWall;
	int SouthWall;
	int WestWall;
}Cell;

typedef struct{
/*
Structure defination to hold an array of direction values for any given target in a maze.
a = array with all direction values 
c = represents the number of direction commands in the array 
NOTE: -1 is dedault for no instruction 
*/
	int a[100]; // arbritary size. can never have more than 100 directions
	int c;
}direct;

direct directions; // initialize a sirect  struct calles directions . Directions will hold all movement commands 

Cell Maze[4][6]; // initilize a 2D Maze structure to represent each cell in the maze. 0 = no wall , 1 = wall 

bool loaded = false; // bool statement that keeps track if a brick is on the forklift or not 

// ALWAYS START FACING NORTH
int robotdirection = 0; //Robot direction 0=North, 1=East, 2=South, 3=West

//Robot's start position
int StartRow = 3;
int StartCol = 4;

//robot's ending position
int EndRow = 2;
int EndCol = 5;

//Robot's current position
int CurrentPosRow = StartRow;
int CurrentPosCol = StartCol;

const int numofbox =5; // number of bricks to pick up 
int BoxRow[numofbox]= {1,0,0,0,0}; // array of location of all the target boxes
int BoxCol[numofbox]= {5,5,3,0,2};


//Maze configuration & solving functions
void generatewalls(); // goes through Maze truct and adds wall values to appropriate spots 
void getdirections(int startrow, int startcol, int endrow,int endcol); //follows left side to compute directions
void cleandirections(); // gets rid of all unnecessary turns and movements 
void followdirections(); // uses the clean directions and follows them chronologically 

//Robot movement functions
void moveforward();// move forward one cell 
void halfforward(); // move forward half a cell 
void quarterforward(); // move forward quarter of a cell 
void moveback(); // move back a cell
void halfback(); // move back half a cell 
void turnl(); // turns robot 90 degrees counter clockwise 
void turnr(); // turns robot 90 degrees clockwise 
void move(int encodea, int encodec, int speeda, int speedc);//monitors and moves robot appropriately
void realign(); // uses back and forward functions to re-align after every turn, if a wall is available in the back 

void forklift(bool lift); // controls the forklift appropriately depending on if a brick is loaded or not 

task main()
{
generatewalls();//start by making the maze and its walls in memory

forklift(true); // lift the forklift above the walls to be able to manover around 


for(int i=0;i<numofbox;i++)
	{
	/*
	For loop for each brick that need to be picked up. This loop gets directions from robots current position to the brick. G
	Goes to the brick. Picks it up and then it calculates the directions to the drop off point. Apon arriving it drops the brick 
	and ends the loop. 
	*/
	
	getdirections(CurrentPosRow, CurrentPosCol, BoxRow[i], BoxCol[i]);
	cleandirections();
	followdirections();
	
	getdirections(CurrentPosRow, CurrentPosCol, EndRow, EndCol);
	cleandirections();
	followdirections();
	}

}

void generatewalls()
{
	for(int i=0;i<4;i++) // initiailize all walls to 0
	{
		for(int p=0;p<6;p++)
		{
			Maze[i][p].NorthWall=0;
			Maze[i][p].SouthWall=0;
			Maze[i][p].EastWall=0;
			Maze[i][p].WestWall=0;

		}
	}


	for(int i=0;i<6;i++) // add outer north and south walls 
	{
		Maze[0][i].SouthWall = 1;
		Maze[3][i].NorthWall = 1;
	}
	for(int i=0;i<4;i++) //  add outer east and west walls 
	{
		Maze[i][0].WestWall = 1;
		Maze[i][5].EastWall = 1;
	}

	//Hard code inner walls ** only write north and east walls
	Maze[0][0].NorthWall = 1;
	Maze[0][5].NorthWall = 1;
	Maze[1][0].NorthWall = 1;
	Maze[1][2].NorthWall = 1;
	Maze[1][5].NorthWall = 1;
	Maze[2][0].NorthWall = 1;
	Maze[2][1].NorthWall = 1;
	Maze[2][2].NorthWall = 1;
	Maze[2][4].NorthWall = 1;
	Maze[0][1].EastWall = 1;
	Maze[0][2].EastWall = 1;
	Maze[0][3].EastWall = 1;
	Maze[1][2].EastWall = 1;
	Maze[1][3].EastWall = 1;
	Maze[3][3].EastWall = 1;

	
	for(int i=1;i<4;i++) //fills in the rest of the inner wall data
	{
		for(int p=0;p<6;p++)
		{
			Maze[i][p].SouthWall = Maze[i-1][p].NorthWall;
		}
	}

	for(int i=1;i<6;i++)//fills in the rest of the inner wall data
	{
		for(int p=0;p<4;p++)
		{
			Maze[p][i].WestWall = Maze[p][i-1].EastWall;
		}
	}
}

void move(int encodea, int encodec, int speeda, int speedc)
{
	bool reached =false; // bool to monitor each motor encodr individually 
	bool a,c; // represents motorA and motorC status

	nMotorEncoder[motorA]=0; // initialize both encoders 
	nMotorEncoder[motorC]=0;
	
	motor[motorA]=speeda; // start motors
	a=true; // true = motors on    false= motors off 
	motor[motorC]=speedc;
	c=true;
	
	while(!reached) // wait until both motors have reached their designated encoder value
		{
			if(speeda > 0) // monitors depending on direction of rotation 
			{
				if(nMotorEncoder[motorA]<encodea)
				{
					motor[motorA]=0;
					a=false;
					if(!c)
						reached=true;}
			}
			else
			{
				if(nMotorEncoder[motorA]>encodea)
				{
					motor[motorA]=0;
					a=false;
					if(!c)
						reached=true;}

			}
			
			if(speedc > 0)
			{
				if(nMotorEncoder[motorC]<encodec)
				{
				motor[motorC]=0;
				c=false;
				if(!a)
					reached=true;}
			}
			else
			{
				if(nMotorEncoder[motorC]>encodec)
				{
				motor[motorC]=0;
				c=false;
				if(!a)
					reached=true;}
			}
			
		}
	wait1Msec(500); // small delay if readjustment needed 
}


void moveforward()
{
	move(-2030, -2030, 70, 70);// use the move function to go forward 
	
	switch (robotdirection){      //increment position value appropriately
		case 0: CurrentPosRow++; break; // Facing North
		case 1: CurrentPosCol++; break; // Facing East
		case 2: CurrentPosRow--; break; // Facing South
		case 3: CurrentPosCol--; break; // Facing West
	}
}

void halfforward()
{
	move(-920, -920, 70, 70);// use the move function to go about half forward 
}

void quarterforward()
{
	move(-277, -277, 70, 70);// use the move function to go quarter forward 
}

void moveback()
{
	move(1840, 1840, -70, -70);// use the move function to go back 
 	// NOTE : since the back function is only used for re-allignment, no changes to cell position are made 
}

void halfback()
{
	move(920, 920, -70, -70);// use the move function to go a little back 
}

void turnl()
{

	move(-1100, 1100, 70, -70);// use the move function to turn left 

	//increment direction value
	robotdirection--;
	if(robotdirection == -1)
		robotdirection = 3;
	realign();
}

void turnr()
{
	move(1100, -1100, -70, 70);// use the move function to turn right

	//increment direction value
	robotdirection++;
	if(robotdirection == 4)
		robotdirection = 0;
	realign();
}


void getdirections(int startrow, int startcol, int endrow,int endcol)
{

	for(int i=0;i<100;i++) // initialize all array values with -1
		directions.a[i]=-1;
	int direction = robotdirection; // fetch robots direction
	int counter = 0; // used to increment array index 
	directions.c=0; // initalize # of direction count 
	while (startrow != endrow || startcol != endcol) // keep doing loop until target position is reached 
	{
		/*
		Algorythm that tracks the left side of the maze and finds the "dirty" path to the final destination. 
		Try to move left, forward, right or back chronologically. 
		NOTE : 0=North 1=East 2=South 3=West
		*/
		directions.c++; 
		if(direction==0) // moving preference if facing North
		{
			if(Maze[startrow][startcol].WestWall == 0)
			{directions.a[counter] = 3; startcol--;direction=3;}
			else if(Maze[startrow][startcol].NorthWall == 0)
			{directions.a[counter] = 0; startrow++; direction=0;}
			else if(Maze[startrow][startcol].EastWall == 0)
			{directions.a[counter] = 1; startcol++; direction=1;}
			else if(Maze[startrow][startcol].SouthWall == 0)
			{directions.a[counter] = 2; startrow--; direction=2;}
			counter++;
		}
		else if(direction==1) // moving preference if facing East
		{
			if(Maze[startrow][startcol].NorthWall == 0)
			{directions.a[counter] = 0; startrow++;direction=0;}
			else if(Maze[startrow][startcol].EastWall == 0)
			{directions.a[counter] = 1; startcol++; direction=1;}
			else if(Maze[startrow][startcol].SouthWall == 0)
			{directions.a[counter] = 2; startrow--; direction=2;}
			else if(Maze[startrow][startcol].WestWall == 0)
			{directions.a[counter] = 3; startcol--; direction=3;}
			counter++;
		}
		else if(direction==2) // moving preference if facing South
		{
			if(Maze[startrow][startcol].EastWall == 0)
			{directions.a[counter] = 1; startcol++; direction=1;}
			else if(Maze[startrow][startcol].SouthWall == 0)
			{directions.a[counter] = 2; startrow--; direction=2;}
			else if(Maze[startrow][startcol].WestWall == 0)
			{directions.a[counter] = 3; startcol--; direction=3;}
			else if(Maze[startrow][startcol].NorthWall == 0)
			{directions.a[counter] = 0; startrow++; direction=0;}
			counter++;
		}
			else if(direction==3) // moving preference if facing West
		{
			if(Maze[startrow][startcol].SouthWall == 0)
			{directions.a[counter] = 2; startrow--; direction=2;}
			else if(Maze[startrow][startcol].WestWall == 0)
			{directions.a[counter] = 3; startcol--; direction=3;}
			else if(Maze[startrow][startcol].NorthWall == 0)
			{directions.a[counter] = 0; startrow++; direction=0;}
			else if(Maze[startrow][startcol].EastWall == 0)
			{directions.a[counter] = 1; startcol++; direction=1;}
			counter++;
		}
	}
}

void cleandirections()
{
	/*
	This function goes through the array and replaces all unnecessary movements with -1
	Some bools and confitions are used to take care of specific scenarios. 
	*/

	bool moved = false; // if initial moves are unnecessary, condition helps increment appropriately
	int left=0; //left array index value of comparison
	int right = 1; // right array index value of comparison 
	while(right<100) // go through the whole array 
	{
		if(abs((directions.a[right]-directions.a[left])) == 2 && directions.a[right]!=-1)//if statement if unnecessary directions
		{
			directions.c-=2; // decremenet number of directions 
			directions.a[left] = -1;
			directions.a[right]=-1;
			if(left==0 || !moved) // takes care if first directions are not needed 
			{
				left =right+1;
				right +=2;}
			else
			{
				do{left--;}while(directions.a[left]==-1); // keep going left in array until you find a direction value
				right++; // look at the next direction}
			if(moved && left==-1) // prevents left to go below 0.
			{left = right; right++;}
			}
		else
		{
			left=right;
			right++;
			moved=true;
			}
		}
}


void followdirections()
{ 
	/*
	follows directions in the array. Before moving forward, robot turns efficiently to face the direction of movement. 
	*/

	while(!SensorValue[S2]){} // waits for the push button. Allows user to re-align if needed. 
	
	for(int i=0;i<100;i++)
	{
		if(directions.a[i]>=0)
		{
			directions.c--; // fecrement direction count once executed 
			if(directions.a[i]==robotdirection) // no need to turn 
			{}
			else if(abs(directions.a[i]-robotdirection)<3 && (directions.a[i]>robotdirection)) // check if we need to turn right
			{
				do{
					turnr();
				}while(robotdirection!=directions.a[i]); //keep turning until target direction is reached 
			}
			else if(robotdirection==3 && directions.a[i]==0)//compensates for certain scenario
			{
				turnr();
			}
			else
			{
				do{
					turnl();
				}while(robotdirection!=directions.a[i]);
			}
			if(directions.c==0 && !loaded) // if this is the last direction command and a brick is not on the bot
			{forklift(false);halfforward();playTone(300, 200); forklift(true); loaded=true; halfback();} // pick up the brick
			else if(directions.c==0 && loaded)// if this is the last direction command and a brick is on the bot
			{halfforward(); forklift(false);playTone(500, 200); halfback();forklift(true); loaded=false;} // drop the brick 
			else
				moveforward();
			}
		}
	}

void forklift(bool lift)
{
	
	/*
	Function incharge of appropriate forklift movement 
	*/
	if(lift) // if true move up
	{
		nMotorEncoder[motorB]=0; // initialize encoder 

		motor[motorB]=50; // start motor up
		
		while(nMotorEncoder[motorB]<1800){}

		motor[motorB]=0; // stop motor
	}
	else // otherwise move down
	{
	nMotorEncoder[motorB]=0; // initialize encoder 

	motor[motorB]=-50; // start motor down 
	
	while(nMotorEncoder[motorB]>-1800){}

	motor[motorB]=0; // stop motor
	}
}
	
void realign()
{
	/*
	After every turn, if there a wall behind the robot, the robot will move back and realign itself. 
	*/

	switch (robotdirection){
		case 0: 
			if(Maze[CurrentPosRow][CurrentPosCol].SouthWall==1)
			{halfback();quarterforward();}
			break; 
		
		case 1: 
			if(Maze[CurrentPosRow][CurrentPosCol].WestWall==1)
			{halfback();quarterforward();}
			break; 
		
		case 2: 
			if(Maze[CurrentPosRow][CurrentPosCol].NorthWall==1)
			{halfback();quarterforward();}
			break; 
		
		case 3: 
			if(Maze[CurrentPosRow][CurrentPosCol].EastWall==1)
			{halfback();quarterforward();}
			break;
	}
}	